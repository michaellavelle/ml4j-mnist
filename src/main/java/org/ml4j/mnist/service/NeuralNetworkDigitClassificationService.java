/*
 * Copyright 2015 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.ml4j.mnist.service;

import java.awt.image.BufferedImage;

import org.ml4j.ConvertToCudaMatrixOptimisationStrategy;
import org.ml4j.CudaForMMulStrategy;
import org.ml4j.DefaultMatrixAdapterStrategy;
import org.ml4j.DoubleMatrixConfig;
import org.ml4j.NoOpMatrixOptimisationStrategy;
import org.ml4j.algorithms.FeaturesMapper;
import org.ml4j.jblas.NoJblasPresentMatrixAdapterStrategy;
import org.ml4j.nn.algorithms.NeuralNetworkHypothesisFunction;
/**
 * DigitClassificationService using a pre-learned NeuralNetworkHypothesisFunction 
 * to classify images of MNIST digits
 * 
 * @author Michael Lavelle
 *
 */
public class NeuralNetworkDigitClassificationService implements DigitClassificationService {

	private NeuralNetworkHypothesisFunction neuralNetworkHypothesisFunction;
	private FeaturesMapper<BufferedImage> bufferedImageFeaturesMapper
	 = new MnistDigitBufferedImageFeaturesMapper(28,28);
	
	public NeuralNetworkDigitClassificationService(NeuralNetworkHypothesisFunction neuralNetworkHypothesisFunction,boolean cudaAvailable,boolean jblasAvailable)
	{
		this.neuralNetworkHypothesisFunction = neuralNetworkHypothesisFunction;

		// Make optimisations to configuration depending on availablity of Cuda/Jblas
		if (!cudaAvailable)
		{
			// The hypothesis functions may have been generated by CUDA matrix strategies, so unconfigure these strategies if we don't want to use CUDA
			if (jblasAvailable)
			{
				DoubleMatrixConfig.setDoubleMatrixStrategy(new DefaultMatrixAdapterStrategy());
			}
			else
			{
				DoubleMatrixConfig.setDoubleMatrixStrategy(new NoJblasPresentMatrixAdapterStrategy());

			}
			this.neuralNetworkHypothesisFunction.getNeuralNetwork().updateForwardPropagationInputMatrixStrategyForCurrentLayers(new NoOpMatrixOptimisationStrategy());
		}
		else
		{
			// If Cuda is available, optimise for GPU matrix-matrix multiplication
			DoubleMatrixConfig.setDoubleMatrixStrategy(new CudaForMMulStrategy());
			this.neuralNetworkHypothesisFunction.getNeuralNetwork().updateForwardPropagationInputMatrixStrategyForCurrentLayers(new ConvertToCudaMatrixOptimisationStrategy());
		}
	}
	
	/**
	 * 
	 * @param mnistData a 28 * 28 image represented as a double[]
	 * @return The predicted digit
	 */
	@Override
	public int getPredictedDigitClassification(double[] mnistData) {
		return getArgMaxIndex(neuralNetworkHypothesisFunction.predict(mnistData));
	}

	/**
	 * 
	 * @param image The image to classify ( must be 28 * 28)
	 * @return The predicted digit
	 */
	@Override
	public int getPredictedDigitClassification(BufferedImage image) {
		return getPredictedDigitClassification(bufferedImageFeaturesMapper.toFeaturesVector(image));
	}
	
	public static int getArgMaxIndex(double[] predictionNeuronValues) {
		Double max = null;
		Integer maxInt = null;
		int ind = 0;
		for (double d : predictionNeuronValues) {
			if (max == null || d > max.doubleValue()) {
				max = d;
				maxInt = ind;
			}
			ind++;
		}
		return maxInt;
	}
	
	/**
	 * 
	 * @param testSetData A mnistData array of 28 * 28 images, each represented as a double[]
	 * @param testSetLabels An array of labels, each represented as a double[] with the index of the '1' element identifying the digit 
	 * @return
	 */
	@Override
	public double getAccuracy(double[][] testSetData, double[][] testSetLabels) {
		return neuralNetworkHypothesisFunction.getAccuracy(testSetData, testSetLabels);
	}

	/**
	 * 
	 * @param mnistData array of 28 * 28 images, each represented as a double[]
	 * @return The predicted digit
	 */
	@Override
	public int[] getPredictedDigitClassifications(double[][] mnistData) {
		int[] predictions = new int[mnistData.length];
		double[][] activations = neuralNetworkHypothesisFunction.predict(mnistData);
		
		for (int index = 0; index < activations.length;index++)
		{
			predictions[index] = getArgMaxIndex(activations[index]);
		}
		return predictions;
	}

}
